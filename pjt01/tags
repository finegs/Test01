!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Array	.\test01.cpp	/^template<typename T> Array<T>::Array() : mSize(kAllocSize)$/;"	f	class:Array
Array	.\test01.hpp	/^class Array$/;"	c
Buffer	.\ts2.cpp	/^   CHAR Buffer[DATA_BUFSIZE];$/;"	m	struct:_SOCKET_INFORMATION	file:
Buffer	.\u.cpp	/^struct Buffer$/;"	s	file:
BytesRECV	.\ts2.cpp	/^   DWORD BytesRECV;$/;"	m	struct:_SOCKET_INFORMATION	file:
BytesSEND	.\ts2.cpp	/^   DWORD BytesSEND;$/;"	m	struct:_SOCKET_INFORMATION	file:
CreateSocketInformation	.\ts2.cpp	/^BOOL CreateSocketInformation(SOCKET s)$/;"	f
DATA_BUFSIZE	.\ts2.cpp	23;"	d	file:
DEFAULT_BUFFER	.\tc.cpp	24;"	d	file:
DEFAULT_COUNT	.\tc.cpp	22;"	d	file:
DEFAULT_MESSAGE	.\tc.cpp	26;"	d	file:
DEFAULT_PORT	.\tc.cpp	23;"	d	file:
DEFAULT_SND_DELAY	.\tc.cpp	25;"	d	file:
DataBuf	.\ts2.cpp	/^   WSABUF DataBuf;$/;"	m	struct:_SOCKET_INFORMATION	file:
DieWithError	.\u.cpp	/^void DieWithError(const char *errorMessage)$/;"	f
FreeSocketInformation	.\ts2.cpp	/^void FreeSocketInformation(DWORD Index)$/;"	f
G_BUF_LEN	.\uc.cpp	9;"	d	file:
G_SEQ	.\uc.cpp	/^		static uint32_t G_SEQ;$/;"	m	struct:Msg	file:
G_SEQ	.\uc.cpp	/^uint32_t Msg::G_SEQ = 0;$/;"	m	class:Msg	file:
INITIAL_SIZE	.\u.cpp	10;"	d	file:
IP_TARGET	.\uc.cpp	8;"	d	file:
LPSOCKET_INFORMATION	.\ts2.cpp	/^} SOCKET_INFORMATION, * LPSOCKET_INFORMATION;$/;"	t	typeref:struct:_SOCKET_INFORMATION	file:
MAXRECVSTRING	.\s.cpp	29;"	d	file:
MSGBUFSIZE	.\listener.cpp	28;"	d	file:
Msg	.\s.cpp	/^			Msg(const my::Msg& _msg) : msg(_msg.msg), from_addr(_msg.from_addr) {}$/;"	f	class:my::Msg
Msg	.\s.cpp	/^			Msg(const my::Msg&& _msg)  : msg(std::move(_msg.msg)), from_addr(std::move(_msg.from_addr)) {}$/;"	f	class:my::Msg
Msg	.\s.cpp	/^			Msg(const std::string& _msg, struct sockaddr_in* _from_addr) $/;"	f	class:my::Msg
Msg	.\s.cpp	/^	class Msg$/;"	c	namespace:my	file:
Msg	.\uc.cpp	/^		Msg() : seq(++G_SEQ) $/;"	f	struct:Msg
Msg	.\uc.cpp	/^struct Msg$/;"	s	file:
Overlapped	.\ts2.cpp	/^   OVERLAPPED Overlapped;$/;"	m	struct:_SOCKET_INFORMATION	file:
PORT	.\ts2.cpp	22;"	d	file:
Packet	.\u.cpp	/^class Packet $/;"	c	file:
SOCKET_INFORMATION	.\ts2.cpp	/^} SOCKET_INFORMATION, * LPSOCKET_INFORMATION;$/;"	t	typeref:struct:_SOCKET_INFORMATION	file:
SerializedPacket	.\u.cpp	/^struct SerializedPacket {$/;"	s	file:
Socket	.\ts2.cpp	/^   SOCKET Socket;$/;"	m	struct:_SOCKET_INFORMATION	file:
SocketArray	.\ts2.cpp	/^LPSOCKET_INFORMATION SocketArray[FD_SETSIZE];$/;"	v
TotalSockets	.\ts2.cpp	/^DWORD TotalSockets = 0;$/;"	v
ValidateArgs	.\tc.cpp	/^void ValidateArgs(int argc, char **argv)$/;"	f
_SOCKET_INFORMATION	.\ts2.cpp	/^typedef struct _SOCKET_INFORMATION {$/;"	s	file:
_TEST01_H_	.\test01.hpp	2;"	d
at	.\test01.cpp	/^template<typename T> T Array<T>::at(size_t x) const$/;"	f	class:Array
bEnd	.\uc.cpp	/^BOOL bEnd = false;$/;"	v
bSendOnly	.\tc.cpp	/^BOOL  bSendOnly = FALSE;                        \/\/ Send data only; don't receive$/;"	v
buf	.\uc.cpp	/^		char buf[G_BUF_LEN];$/;"	m	struct:Msg	file:
comp_dat	.\t.cpp	/^int comp_dat(void const* a, void const* b)$/;"	f
dat	.\t.cpp	/^} dat[] = { {1, "Foo"}$/;"	v	typeref:struct:data
data	.\t.cpp	/^struct data {$/;"	s	file:
data	.\u.cpp	/^		char data[MaxDataSize];$/;"	m	class:Packet	file:
data	.\u.cpp	/^	char data[MaxDataSize];$/;"	m	struct:SerializedPacket	file:
data	.\u.cpp	/^	void* data;$/;"	m	struct:Buffer	file:
deserialize	.\u.cpp	/^void Packet::deserialize(void* message)$/;"	f	class:Packet
dstPort	.\uc.cpp	/^WORD srcPort,dstPort;$/;"	v
dwCount	.\tc.cpp	/^DWORD dwCount   = DEFAULT_COUNT; \/\/ Number of times to send message$/;"	v
from_addr	.\s.cpp	/^			struct sockaddr_in* from_addr;$/;"	m	class:my::Msg	typeref:struct:my::Msg::sockaddr_in	file:
getCMsg	.\s.cpp	/^			const std::string& getCMsg() const { return msg; }$/;"	f	class:my::Msg
getFromAddr	.\s.cpp	/^			struct sockaddr_in* getFromAddr() const { return from_addr; }$/;"	f	class:my::Msg
handleRecv	.\c.cpp	/^void handleRecv(int sock)$/;"	f
handleServer	.\ts.cpp	/^int handleServer(int port) $/;"	f
handle_recv	.\s.cpp	/^void handle_recv(int sock)$/;"	f
handle_send	.\s.cpp	/^void handle_send(int sock)$/;"	f
iPort	.\tc.cpp	/^int   iPort     = DEFAULT_PORT;    \/\/ Port on server to connect to$/;"	v
initializeElements	.\test01.cpp	/^template<typename T> void Array<T>::initializeElements()$/;"	f	class:Array
initudp	.\ts.cpp	/^int initudp(int port)$/;"	f
kAllocSize	.\test01.hpp	/^       static const size_t kAllocSize = 4;$/;"	m	class:Array
mElems	.\test01.hpp	/^       T* mElems;$/;"	m	class:Array
mSize	.\test01.hpp	/^       size_t mSize;$/;"	m	class:Array
main	.\c.cpp	/^int main(int argc, char *argv[])$/;"	f
main	.\listener.cpp	/^int main(int argc, char *argv[])$/;"	f
main	.\s.cpp	/^int main(int argc, char *argv[])$/;"	f
main	.\sender.cpp	/^int main(int argc, char *argv[])$/;"	f
main	.\t.cpp	/^int main(int argc, char* argv[])$/;"	f
main	.\tc.cpp	/^int main(int argc, char **argv)$/;"	f
main	.\test01.cpp	/^int main(int argc,char* argv[])$/;"	f
main	.\ts2.cpp	/^int main(int argc, char **argv)$/;"	f
main	.\uc.cpp	/^int main(int argc, char* argv[])$/;"	f
makeSocket	.\uc.cpp	/^SOCKET makeSocket(WORD wPort)$/;"	f
marshal	.\uc.cpp	/^unsigned char* marshal(const Msg* msg, unsigned char* buf)$/;"	f
msg	.\s.cpp	/^			std::string msg;$/;"	m	class:my::Msg	file:
my	.\s.cpp	/^namespace my$/;"	n	file:
nSndDelay	.\tc.cpp	/^DWORD nSndDelay = DEFAULT_SND_DELAY;            \/\/ Send Delay Secs$/;"	v
new_buffer	.\u.cpp	/^struct Buffer* new_buffer(size_t data_len = INITIAL_SIZE)$/;"	f
next	.\u.cpp	/^	int next;$/;"	m	struct:Buffer	file:
nr	.\t.cpp	/^	int nr;$/;"	m	struct:data	file:
operator =	.\s.cpp	/^			Msg& operator=(Msg& o)$/;"	f	class:my::Msg
operator =	.\s.cpp	/^			Msg& operator=(Msg&& o)$/;"	f	class:my::Msg
operator []	.\test01.cpp	/^template<typename T> T& Array<T>::operator[](size_t x)$/;"	f	class:Array
popSendQueue	.\s.cpp	/^my::Msg* popSendQueue()$/;"	f
pushSendQueue	.\s.cpp	/^void pushSendQueue(my::Msg* msg)$/;"	f
rcvTask	.\uc.cpp	/^DWORD WINAPI rcvTask(void* pParam)$/;"	f
reserve_space	.\u.cpp	/^void reserve_space(Buffer* b, size_t bytes)$/;"	f
resize	.\test01.cpp	/^template<typename T> void Array<T>::resize(size_t newSize)$/;"	f	class:Array
rhs	.\test01.hpp	/^        Array<T>& operator=(const Array<T>& rhs) = delete;$/;"	m	class:Array
sendData	.\uc.cpp	/^BOOL sendData(void* pParam, WORD wDstPort, unsigned char* sndBuf, size_t sndBufLen)$/;"	f
sendQueueCV	.\s.cpp	/^std::condition_variable sendQueueCV;$/;"	v
sendQueueMtx	.\s.cpp	/^std::mutex sendQueueMtx;$/;"	v
senderId	.\u.cpp	/^		int senderId;$/;"	m	class:Packet	file:
senderId	.\u.cpp	/^	int senderId;$/;"	m	struct:SerializedPacket	file:
seq	.\uc.cpp	/^		uint32_t seq;$/;"	m	struct:Msg	file:
sequenceNumber	.\u.cpp	/^		int sequenceNumber;$/;"	m	class:Packet	file:
sequenceNumber	.\u.cpp	/^	int sequenceNumber;$/;"	m	struct:SerializedPacket	file:
serialize	.\u.cpp	/^void* Packet::serialize()$/;"	f	class:Packet
serialize_int	.\u.cpp	/^void serialize_int(int x, Buffer* b)$/;"	f
set	.\test01.cpp	/^template<typename T> void Array<T>::set(size_t x, const T& val)$/;"	f	class:Array
size	.\u.cpp	/^	size_t size;$/;"	m	struct:Buffer	file:
src	.\test01.hpp	/^        Array(const Array<T>& src) = delete;$/;"	m	class:Array
srcPort	.\uc.cpp	/^WORD srcPort,dstPort;$/;"	v
szMessage	.\tc.cpp	/^      szMessage[1024];                      \/\/ Message to send to sever$/;"	v
szServer	.\tc.cpp	/^char  szServer[128],                          \/\/ Server to connect to$/;"	v
unmarshal	.\uc.cpp	/^Msg* unmarshal(unsigned char* buf, Msg* msg = nullptr)$/;"	f
usage	.\tc.cpp	/^void usage()$/;"	f
value	.\t.cpp	/^	char const* value;$/;"	m	struct:data	file:
~Array	.\test01.cpp	/^template<typename T> Array<T>::~Array()$/;"	f	class:Array
~Msg	.\s.cpp	/^			~Msg() $/;"	f	class:my::Msg
